namespace LeetCodeSolutions.Medium
{
    public class N16_3SumCloset // Если хотите вставить задачу в LeetCode то нужно изменить название класса на "Solution"
    {
        public int ThreeSumClosest(int[] nums, int target)
        {
            if (nums.Length < 3)
                return 0;

            Array.Sort(nums);
            int start = 0;
            int left = 1;
            int right = nums.Length - 1;
            int direction = nums[start] + nums[left] + nums[right] > 0 ? 1 : 0;
            int minDistance = int.MaxValue;
            int sum = int.MinValue;

            while (start < nums.Length - 2)
            {
                while (left < right)
                {
                    int currSum = nums[start] + nums[left] + nums[right];
                    if (currSum == target)
                        return target;

                    if (currSum < target)
                        left++;
                    else
                        right--;

                    if (Math.Abs(currSum - target) < minDistance)
                    {
                        sum = currSum;
                        minDistance = Math.Abs(currSum - target);
                    }
                }
                start++;
                left = start + 1;
                right = nums.Length - 1;
            }
            return sum;
        }

    }
}


//Пояснение:
//Проверка длины массива:

//Сначала проверяется, содержит ли массив nums хотя бы три элемента. Если нет, метод возвращает 0, так как нет смысла искать сумму трёх элементов.
//Сортировка массива:

//Массив nums сортируется. Это необходимо для упрощения поиска комбинаций с использованием двух указателей.
//Инициализация переменных:

//start инициализируется на первом элементе, left на втором, и right на последнем элементе массива.
//Переменные direction, minDistance, и sum инициализируются для отслеживания минимального расстояния до целевой суммы и самого близкого найденного значения суммы.
//Внешний цикл:

//Внешний цикл перебирает элементы массива начиная с первого. Для каждого элемента start он рассматривает комбинации элементов с использованием двух других указателей (left и right).
//Внутренний цикл:

//Внутренний цикл выполняется до тех пор, пока указатели left и right не пересекутся.
//Рассчитывается сумма элементов, на которые указывают указатели start, left, и right.
//Если сумма совпадает с целевой суммой, возвращается целевая сумма, так как это идеальный случай.
//Обновление указателей и значений:

//Если сумма меньше целевой, left сдвигается вправо (увеличивается), чтобы увеличить сумму.
//Если сумма больше целевой, right сдвигается влево (уменьшается), чтобы уменьшить сумму.
//При каждом изменении указателей обновляется минимальное расстояние между текущей суммой и целевой суммой, если новое расстояние меньше текущего.
//Возвращение результата:

//После завершения всех итераций возвращается значение sum, которое является суммой трех элементов, ближайшей к целевой сумме.
//Временная и пространственная сложность:
//Временная сложность: O(n ^ 2), где n — количество элементов в массиве. Основная сложность обусловлена двойным перебором элементов массива (внешний цикл и внутренний цикл).
//Пространственная сложность: O(1), так как используется фиксированное количество переменных для хранения данных и индексов, не зависящих от размера входных данных.